# a1-forrelease

PART - 1 

# Solver2021:

For the puzzle 2021, it has 25 tiles. The rotations that can be made, are R1..5,L1..5,U1..5,D1..5,Icc,Ic,Occ,Oc total 24 moves. Then the successors that can generate from a given state are 24. 

For the Cost function f(x) = g(x) + h(x), where g(x) is the direction in which it is going, increamented by 1
h(x) is heuristic function, which is Manhattan Distance which checks the each tile position.

We have tried Number of Misplaced tiles, which is not admissible as well as not consistent. So Manhattan distance is admissible, without considering the rotations. But when we considered rotations, it is no more admissible. But it gives the sub-optimal solutions.


Rotations:
   - The L1 ( left rotation of a particular row is cyclic)
   - Similar with R1
   - Outer ring Clock-wise, a tile present in the board is shifted clock or anti-clock-wise
   - Similar with Inner ring

Implemented A*,
   -insert the s into Closed
   - repeat for every state in successors
   -     -s' in closed, skip the s'
         -s' in fringe with larger cost, then remove from fringe
         -s' not in fringe insert into fringe.
      
Storing into the fringe, used heapqueue for sorting it. The heapq inserts new state into the respective order of the cost. Popping the state with lowest cost function(Fx) which is best state among the others, by considering both g(x) and h(x). and storing the path( rotations made to the board) into the fringe as well.

fringe->(fx,state,path)

Making the heuristic admissible, is dividing the max tiles rotated for the particular rotation. L,R - 5  Ic,Icc-8 and Occ,Oc - 16. dividing the manhattan distance got from the generated successor with its rotation cost. 

pop the current state from the fringe, store the cost,path as values in the state key by using Dict
store the current state into closed list as well

check if initial_board is the Goal_state, if so return path

If a state is to be inserted into fringe,
      
      - generate the successors for the curr_state
            -repeat:
               -- it needs to check if it reached goal, then return path + current_move
               -- checking if curr_state in fringe, if so discard
               -- check in the fringe dict, if the state exists, if so, having less cost, remove the old state and update the fringe dict with less cost for the same state
               -- if state not in fringe dict, insert into fringe as well as fringe_dict
 
Challenges:
Designing the right heuristic which is admissible as well as consistent. Explored more heuristics that have used in similar puzzles. Tried to make the heuristic admissible. But we restricted the state space and got the solution to find the list of rotations to get the goal state.

Then John Holt, has come up with the Heuristic design, where the equation C = 16x + 8y + 5z, which are the moves that solves manhattan_dist // 16,8,5 which are max tiles rotation for the particular rotation. example manhattan dist=27, it checks for the nearest number, so that it can divide manhattan dist, by max tile movement. (0,0,2) and (1,0,2). By considering min sum of these will be 3. Then divide the manhattan by min_xyz. Which is always less than or equal to the true cost. Which is admissible and consistent. But when coming to practical implementation, which gives the solution but not the correct one.

Questions:

1. Branching Factor: The branching factor for the search tree is, the successors(childs) generated by the successor function will be 24, which are rotations generated for a board.
2. The successors or rotations that can be generated for this puzzle using BFS is 24 ^ 7, where 24 is the total successors that can be generated, and depth is 7 (b^d)
